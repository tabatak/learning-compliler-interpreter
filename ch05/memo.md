# 宣言の処理と記号表

## 5.1 記号表の作成

## 5.2 記号表への登録

## 5.3 記号表の探索
### リニアサーチ
### バイナリサーチ
### ハッシュ法
- クローズドハッシュ法（内部ハッシュ法）
- オープンハッシュ法（外部ハッシュ法）

## 5.4 コンパイルの開始
### 宣言の処理
### スタートアップ処理
### 関数アドレスのバックパッチ
Cでは関数プロトタイプがあれば、関数定義前にその関数の呼び出しが可能。

仮番地を使ってCALL命令を生成して起き、関数の実行開始アドレスが決定したら、その仮番地を修正する。
実際には解析が終了してから、一括して未決定関数アドレスの修正を行う。

あとから修正することを「バックパッチ(back-patching)」と呼ぶ。

### ジャンプ命令のバックパッチ
### アセンブラコード生成時のジャンプ命令の処理
インタプリタで即実行する場合は、生成コードを主記憶上に配置するため、バックパッチ処理が可能。

アセンブラコードを外部記憶に直接出力するタイプの場合、バックパッチ処理は不可能。
この場合はアセンブラのラベル機能を使用。

### 静的領域サイズの格納
プログラム実行時に用いるメモリ領域は、静的領域とスタック領域に分かれる。

静的領域には大域変数や文字列リテラルなどを割り当てる。
サイズは解析が終了したときに決定する。

### 宣言の切り分け
### 型名と識別子の設定

## 5.5 変数宣言の処理
### 変数宣言の処理方法
変数宣言ならば、配列かどうかをチェック。
配列なら配列長を取得。
仮設定したtmpTbの内容を、変数として記号表に登録する。

### 配列宣言と整数定数式の判定
### 大域名と局所名の管理
大域名と局所名は、別の記号表で管理することも可能。
ひとつの記号表で、使い分けすることも可能で効果的。

大域変数名や関数名は、大域用領域に登録。大域用領域はコンパイル処理が終了されるまで維持される。
この時点では局所用領域は存在しない。

関数の解析に入り、引数やローカル変数の宣言を処理する際に、局所用領域を作成し、登録する。
関数の解析が終了すると、ローカル記号表は不要となるためクリアする。

※内容と関係ないけど、大域とグローバル、局所とローカルがばらばらと出てくるから読みにくい。

TODO:
図5-3でb行時点とc行時点の"p1"が大域変数になってるのはなぜなのか？

### 記号表の領域管理
### 局所用記号表の開始と終了
```
void foo(int a){ int b; ...}
```
引数a以降がローカル。そのためfooは大域用記号表で、a, bは局所用記号表で管理する。
局所用記号表を解放すると、大域用記号表にはfooだけが残る。
関数解析が終了した後も、関数プロトタイプは他から参照されるため、「関数fooは引数aを持っている」という情報は、大域管理する必要がある。

TODO:
なぜ最初から大域管理しないのかが理解できていない。

### 変数アドレスの設定
### 境界調整
メモリ上のデータを1バイト単位であつかうコンピュータ(バイトマシンという)の場合、メモリ割り付けをする際に、境界調整(アラインメント)という制約がかかることがある。
これはメモリアクセスの際の機械的なメカニズムに依存する。
コンピュータで標準となる整数型(=int型)が4バイトであれば、その方の変数は4の倍数の番地に置くと、アクセスが速くなる。

### 初期化の処理

## 5.6 関数宣言の処理
### 関数宣言の処理方法
1. 関数の名前、型、実行コードの先頭アドレス、引数の個数、の登録
2. 引数名と引数アドレスを別の記号表に登録
3. 関数実行に必要なメモリ領域(フレーム)を確保するコードを生成
4. 戻り番地と実引数を受け取り、フレームに格納するためのコードを生成
5. 関数本体であるブロックの処理
6. フレームの解放と制御を戻す処理

### 局所用記号表の用意
### 引数の処理
### 関数プロトタイプの設定
### 関数の実行開始アドレスの設定
### 引数アドレスの設定
### 関数の正しさの確認
### 関数本体の解析
### main関数の処理
プログラムがmain()関数から実行開始されるように「起動番地設定」の処理を行う。

### 記号表の後処理
