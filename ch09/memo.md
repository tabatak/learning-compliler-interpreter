# 関数呼び出しと関数処理

## 9.1 関数呼び出しの手順

関数が実行中であること -> 「駆動」

駆動中の関数は、あるサイズのローカルメモリ領域を必要とする -> 「駆動レコード」または「フレーム」

フレームは主記憶の実行時スタック領域上にスタック形式で確保される。関数が駆動されるとフレームが確保され、終了すると解放される。

フレームには「戻り番地」「引数」「局所変数」などが割り当てられる。

関数呼び出し側
1. 実引数をオペランドスタックに積む
2. 保存環境情報をオペランドスタックに積む
3. 戻り番地をオペランドスタックに積む
4. 関数を呼び出す

関数本体側
1. 関数で使用するフレームを確保する
2. 戻り番地を取り出し、フレームに入れる
3. 保存すべき環境情報を取り出し、フレームに入れる
4. 実引数を取り出し、フレームに入れる

5. 関数内で宣言された局所変数を割り当てる
6. 関数本体の文を処理する

7. 戻り値をオペランドスタックに積む
8. 保存していた環境情報をオペランドスタックに積む
9. 戻り番地をオペランドスタックに積む
10. フレーム領域を解放する
11. RET命令で処理を戻す

## 9.2 フレームの確保

## 9.3 レジスタマシンでのフレームの確保
x86系CPUでは、ベースポインタBPとスタックポインタSPを使ってフレームを管理する。
BPでメモリ上の起点を決め、SPがフレームの終端を管理。
局所変数アドレスは「BP+相対番地」で決まる。

２つのレジスタでフレームk南里を行うと、ローカルメモリを柔軟に活用できる。

## 9.4 CALL命令とRET命令

## 9.5 オペランドスタックと実行時スタック
レジスタ型マシンの場合、演算の途中結果はレジスタに保持される。
関数が利用するフレームは主記憶上のスタック領域にスタック形式で確保される。

一方スタック型マシンの場合、演算の途中結果はレジスタではなくオペランドスタックに格納される。

スタック方式の実マシンがある場合は、通常以下のような構成になる。
- オペランドスタックは容量は少ないが高速アクセス可能
- 主メモリはアクセス速度は普通だが大容量

