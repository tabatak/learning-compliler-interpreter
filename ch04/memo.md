# 式の解析

## 4.1 式の表現
式の表現の種類
```
a + b  -> 中置記法
a b +  -> 後置記法
+ a b  -> 前置記法
```

## 4.2 演算子順位表による構文解析

### 逆ポーランド記法を使う式解析
演算子の強さの順序（演算子順位）に着目して、元式を後置記法に変換。

逆ポーランド記法で並べ替えると、()の処理や、優先順位のことを考える必要がなくなる。
->要素の出てきた順番に処理すれば答えが得られる。

1. 式の返還 -> 元の式を逆ポーランド記法で並べ替える（=中間言語にコンパイル）
2. 式の評価 -> 逆ポーランド記法になった式を評価して答えを得る（=コンパイルした結果を実行）

### 変換パターン
1. 変数（や定数）なら、そのまま出力する
2. 演算子なら、現在のスタックトップにある要素（最後に積んだもの）と、新しく読んだ要素を比較して適切な処理をする

### 式の評価
逆ポーランド記法で書かれた式の評価。

1. 先頭から見ていき、トークンがある間以下の処理を繰り返す
  ```
  要素が変数（や定数）なら、その値をPUSHする
  要素が演算子ならPOPした値をn2に、もう一度POPした値をn1に入れ、n1 演算子 n2 の計算を行い、結果をPUSHする
  ```
2. 最後にスタックに残った値（1個残るはず）をPOPして「結果」とする


## 4.3 再帰的下向き構文解析

- 構文規則と１対１に対応したコードを作るのでわかりやすい
- 構文規則そのものが、演算子順位を含んでいるので、あらためて順位を考慮する必要はない
- 式だけでなく、一般文の解析にも用いることができ、適用範囲が広い

### 電卓プログラムを作る

- 利用できる変数はa～zの26個
- a=10+20の形で演算と代入処理ができる
- ( ) + - * / の演算子を利用できる
- ？ で出力する ( 例： ? a )
- <改行>だけを入力すると処理を終了する

操作例
```
a = 10
b = 20
c = (a + b) * 5 - (30 - 20) / 5
? c
? 1 + 2 + a + b
``` 

### 構文規則の制約
再帰的下向き構文解析を行う場合、構文規則は次の条件を守ることが必要

- 次のトークンを読んだとき、構文規則として何をなすべきかが一意に決まる
- 左再帰性をもたない -> 再帰性をもたない構文形式に変換する必要がある

C言語の構文規則では、先頭のトークンだけでは処理が決定しないことがある
以下でhあ3爪のトークンまで進まないと方向が決定しない。
```
int abc;
int abc(void){}
```

Pascalの構文規則は、先頭のトークンだけで処理が決まるように設計されている。
```
先頭がvar -> 変数宣言
先頭がprocedure -> 手続き宣言
先頭がfunction -> 関数宣言
```

### 条件式と代入式の処理
Pascalの構文規則では、「条件式」と「計算式」を別々に処理する。「代入処理」も別に処理する。
```
statement()関数 -> while文、if文、代入文などを処理
condition()関数 -> < <= > >= などの条件式を処理
expression()関数 -> + - * / などの計算式を処理
```

C言語では「条件式」、「計算式」、「代入処理」をすべて「式」として処理。
-> 条件式も「式」として処理されるため、数値を返却する。（TODO: よくわかってない）
-> 条件式を右辺値として用いることもできる。

### 代入処理と式の値
Cでは代入処理('=')も「式」のため、「式の値」が発生する。
そのため、条件式に代入演算子を使うことが可能。
```C
if((fin = fopen(fname, "r")) == NULL) exit(1);   //ファイルオープン
while((ch = fgetc(fin)) != EOF){                //ファイル末尾まで1文字読み込む
  putchar(ch);
}
```
最初の文は、finにfopen()関数の戻り値を代入したときに、同じ値が「式の値」としてスタックに積まれる。

### 式の値の削除

### 多重代入と右結合
```C
a = b = c = 10;
```
は以下の順に右から処理される。 -> 右結合
```C
a = (b = (c = 10));
```

反対に、+ - * / などの演算子は左から順に処理される。 -> 左結合

### C方式の構文規則

### C方式の式解析ルーチン

### 解析ルーチンの再帰的記述

## 4.4 LexとYacc

## 4.5 解析木と構文木
